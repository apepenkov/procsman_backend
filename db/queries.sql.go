// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProcess = `-- name: CreateProcess :one
INSERT INTO process (name, process_group_id, color, executable_path, arguments, working_directory, environment,
                     configuration, enabled)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, name, process_group_id, color, enabled, executable_path, arguments, working_directory, environment, status, configuration
`

type CreateProcessParams struct {
	Name             string            `json:"name"`
	ProcessGroupID   pgtype.Int4       `json:"process_group_id"`
	Color            pgtype.Text       `json:"color"`
	ExecutablePath   string            `json:"executable_path"`
	Arguments        string            `json:"arguments"`
	WorkingDirectory string            `json:"working_directory"`
	Environment      map[string]string `json:"environment"`
	Configuration    Configuration     `json:"configuration"`
	Enabled          bool              `json:"enabled"`
}

func (q *Queries) CreateProcess(ctx context.Context, arg CreateProcessParams) (Process, error) {
	row := q.db.QueryRow(ctx, createProcess,
		arg.Name,
		arg.ProcessGroupID,
		arg.Color,
		arg.ExecutablePath,
		arg.Arguments,
		arg.WorkingDirectory,
		arg.Environment,
		arg.Configuration,
		arg.Enabled,
	)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProcessGroupID,
		&i.Color,
		&i.Enabled,
		&i.ExecutablePath,
		&i.Arguments,
		&i.WorkingDirectory,
		&i.Environment,
		&i.Status,
		&i.Configuration,
	)
	return i, err
}

const createProcessGroup = `-- name: CreateProcessGroup :one
INSERT INTO process_group (name, color, scripts_configuration)
VALUES ($1, $2, $3) RETURNING id, name, color, scripts_configuration
`

type CreateProcessGroupParams struct {
	Name                 string        `json:"name"`
	Color                pgtype.Text   `json:"color"`
	ScriptsConfiguration Configuration `json:"scripts_configuration"`
}

func (q *Queries) CreateProcessGroup(ctx context.Context, arg CreateProcessGroupParams) (ProcessGroup, error) {
	row := q.db.QueryRow(ctx, createProcessGroup, arg.Name, arg.Color, arg.ScriptsConfiguration)
	var i ProcessGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.ScriptsConfiguration,
	)
	return i, err
}

const deleteProcess = `-- name: DeleteProcess :exec
DELETE
FROM process
WHERE id = $1
`

func (q *Queries) DeleteProcess(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProcess, id)
	return err
}

const deleteProcessGroup = `-- name: DeleteProcessGroup :exec
DELETE
FROM process_group
WHERE id = $1
`

func (q *Queries) DeleteProcessGroup(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProcessGroup, id)
	return err
}

const getAllLogFiles = `-- name: GetAllLogFiles :many
SELECT id, process_id, start_time, end_time, path
FROM logs
WHERE process_id=$1
ORDER BY id
`

func (q *Queries) GetAllLogFiles(ctx context.Context, processID pgtype.Int4) ([]Log, error) {
	rows, err := q.db.Query(ctx, getAllLogFiles, processID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.StartTime,
			&i.EndTime,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProcessEvents = `-- name: GetAllProcessEvents :many
SELECT id, process_id, event, created_at, additional_info
FROM process_event
ORDER BY id ASC
`

func (q *Queries) GetAllProcessEvents(ctx context.Context) ([]ProcessEvent, error) {
	rows, err := q.db.Query(ctx, getAllProcessEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessEvent{}
	for rows.Next() {
		var i ProcessEvent
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.Event,
			&i.CreatedAt,
			&i.AdditionalInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByName = `-- name: GetGroupsByName :many
SELECT id, name, color, scripts_configuration
FROM process_group
WHERE name = $1
`

func (q *Queries) GetGroupsByName(ctx context.Context, name string) ([]ProcessGroup, error) {
	rows, err := q.db.Query(ctx, getGroupsByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessGroup{}
	for rows.Next() {
		var i ProcessGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.ScriptsConfiguration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogFiles = `-- name: GetLogFiles :many
SELECT id, process_id, start_time, end_time, path
FROM logs
WHERE process_id = $1
ORDER BY id ASC
`

func (q *Queries) GetLogFiles(ctx context.Context, processID pgtype.Int4) ([]Log, error) {
	rows, err := q.db.Query(ctx, getLogFiles, processID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.StartTime,
			&i.EndTime,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogFilesFromTo = `-- name: GetLogFilesFromTo :many
SELECT id, process_id, start_time, end_time, path
FROM logs
WHERE process_id = $1
  AND start_time >= $2
  AND (end_time <= $3 OR end_time IS NULL)
ORDER BY id
`

type GetLogFilesFromToParams struct {
	ProcessID pgtype.Int4      `json:"process_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) GetLogFilesFromTo(ctx context.Context, arg GetLogFilesFromToParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, getLogFilesFromTo, arg.ProcessID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.StartTime,
			&i.EndTime,
			&i.Path,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcess = `-- name: GetProcess :one
SELECT id, name, process_group_id, color, enabled, executable_path, arguments, working_directory, environment, status, configuration
FROM process
WHERE id = $1
`

func (q *Queries) GetProcess(ctx context.Context, id int32) (Process, error) {
	row := q.db.QueryRow(ctx, getProcess, id)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProcessGroupID,
		&i.Color,
		&i.Enabled,
		&i.ExecutablePath,
		&i.Arguments,
		&i.WorkingDirectory,
		&i.Environment,
		&i.Status,
		&i.Configuration,
	)
	return i, err
}

const getProcessByName = `-- name: GetProcessByName :many
SELECT id, name, process_group_id, color, enabled, executable_path, arguments, working_directory, environment, status, configuration
FROM process
WHERE name = $1
`

func (q *Queries) GetProcessByName(ctx context.Context, name string) ([]Process, error) {
	rows, err := q.db.Query(ctx, getProcessByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Process{}
	for rows.Next() {
		var i Process
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProcessGroupID,
			&i.Color,
			&i.Enabled,
			&i.ExecutablePath,
			&i.Arguments,
			&i.WorkingDirectory,
			&i.Environment,
			&i.Status,
			&i.Configuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessEvents = `-- name: GetProcessEvents :many
SELECT id, process_id, event, created_at, additional_info
FROM process_event
WHERE process_id = $1
ORDER BY id ASC
`

func (q *Queries) GetProcessEvents(ctx context.Context, processID pgtype.Int4) ([]ProcessEvent, error) {
	rows, err := q.db.Query(ctx, getProcessEvents, processID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessEvent{}
	for rows.Next() {
		var i ProcessEvent
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.Event,
			&i.CreatedAt,
			&i.AdditionalInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessEventsAfter = `-- name: GetProcessEventsAfter :many
SELECT id, process_id, event, created_at, additional_info
FROM process_event
WHERE process_id = $1
  AND created_at >= $2
ORDER BY id ASC
`

type GetProcessEventsAfterParams struct {
	ProcessID pgtype.Int4      `json:"process_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetProcessEventsAfter(ctx context.Context, arg GetProcessEventsAfterParams) ([]ProcessEvent, error) {
	rows, err := q.db.Query(ctx, getProcessEventsAfter, arg.ProcessID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessEvent{}
	for rows.Next() {
		var i ProcessEvent
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.Event,
			&i.CreatedAt,
			&i.AdditionalInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessEventsFromTo = `-- name: GetProcessEventsFromTo :many
SELECT id, process_id, event, created_at, additional_info
FROM process_event
WHERE process_id = $1
  AND created_at >= $2
  AND created_at <= $3
    ORDER BY id DESC
    LIMIT $4
`

type GetProcessEventsFromToParams struct {
	ProcessID   pgtype.Int4      `json:"process_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
	Limit       int32            `json:"limit"`
}

func (q *Queries) GetProcessEventsFromTo(ctx context.Context, arg GetProcessEventsFromToParams) ([]ProcessEvent, error) {
	rows, err := q.db.Query(ctx, getProcessEventsFromTo,
		arg.ProcessID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessEvent{}
	for rows.Next() {
		var i ProcessEvent
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.Event,
			&i.CreatedAt,
			&i.AdditionalInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessGroup = `-- name: GetProcessGroup :one
SELECT id, name, color, scripts_configuration
FROM process_group
WHERE id = $1
ORDER BY id ASC
`

func (q *Queries) GetProcessGroup(ctx context.Context, id int32) (ProcessGroup, error) {
	row := q.db.QueryRow(ctx, getProcessGroup, id)
	var i ProcessGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.ScriptsConfiguration,
	)
	return i, err
}

const getProcessGroupByName = `-- name: GetProcessGroupByName :many
SELECT id, name, color, scripts_configuration
FROM process_group
WHERE name = $1
ORDER BY id ASC
`

func (q *Queries) GetProcessGroupByName(ctx context.Context, name string) ([]ProcessGroup, error) {
	rows, err := q.db.Query(ctx, getProcessGroupByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessGroup{}
	for rows.Next() {
		var i ProcessGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.ScriptsConfiguration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessGroups = `-- name: GetProcessGroups :many
SELECT id, name, color, scripts_configuration
FROM process_group
ORDER BY id ASC
`

func (q *Queries) GetProcessGroups(ctx context.Context) ([]ProcessGroup, error) {
	rows, err := q.db.Query(ctx, getProcessGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessGroup{}
	for rows.Next() {
		var i ProcessGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.ScriptsConfiguration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessStats = `-- name: GetProcessStats :many
SELECT id, process_id, created_at, cpu_usage, cpu_usage_percentage, memory_usage
FROM process_stats
WHERE process_id = $1
ORDER BY id ASC
`

func (q *Queries) GetProcessStats(ctx context.Context, processID pgtype.Int4) ([]ProcessStat, error) {
	rows, err := q.db.Query(ctx, getProcessStats, processID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessStat{}
	for rows.Next() {
		var i ProcessStat
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.CreatedAt,
			&i.CpuUsage,
			&i.CpuUsagePercentage,
			&i.MemoryUsage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessStatsFromTo = `-- name: GetProcessStatsFromTo :many
SELECT id, process_id, created_at, cpu_usage, cpu_usage_percentage, memory_usage
FROM process_stats
WHERE process_id = $1
  AND created_at >= $2
  AND created_at <= $3
ORDER BY id
`

type GetProcessStatsFromToParams struct {
	ProcessID   pgtype.Int4      `json:"process_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

func (q *Queries) GetProcessStatsFromTo(ctx context.Context, arg GetProcessStatsFromToParams) ([]ProcessStat, error) {
	rows, err := q.db.Query(ctx, getProcessStatsFromTo, arg.ProcessID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessStat{}
	for rows.Next() {
		var i ProcessStat
		if err := rows.Scan(
			&i.ID,
			&i.ProcessID,
			&i.CreatedAt,
			&i.CpuUsage,
			&i.CpuUsagePercentage,
			&i.MemoryUsage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcesses = `-- name: GetProcesses :many
SELECT id, name, process_group_id, color, enabled, executable_path, arguments, working_directory, environment, status, configuration
FROM process
ORDER BY id ASC
`

func (q *Queries) GetProcesses(ctx context.Context) ([]Process, error) {
	rows, err := q.db.Query(ctx, getProcesses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Process{}
	for rows.Next() {
		var i Process
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProcessGroupID,
			&i.Color,
			&i.Enabled,
			&i.ExecutablePath,
			&i.Arguments,
			&i.WorkingDirectory,
			&i.Environment,
			&i.Status,
			&i.Configuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessesByGroup = `-- name: GetProcessesByGroup :many
SELECT id, name, process_group_id, color, enabled, executable_path, arguments, working_directory, environment, status, configuration
FROM process
WHERE process_group_id = $1
ORDER BY id ASC
`

func (q *Queries) GetProcessesByGroup(ctx context.Context, processGroupID pgtype.Int4) ([]Process, error) {
	rows, err := q.db.Query(ctx, getProcessesByGroup, processGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Process{}
	for rows.Next() {
		var i Process
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProcessGroupID,
			&i.Color,
			&i.Enabled,
			&i.ExecutablePath,
			&i.Arguments,
			&i.WorkingDirectory,
			&i.Environment,
			&i.Status,
			&i.Configuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groupExistsByName = `-- name: GroupExistsByName :one
SELECT EXISTS(SELECT 1
              FROM process_group
              WHERE name = $1) AS exists
`

func (q *Queries) GroupExistsByName(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, groupExistsByName, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertProcessEvent = `-- name: InsertProcessEvent :one
INSERT INTO process_event (process_id, event, additional_info)
VALUES ($1, $2, $3) RETURNING id, process_id, event, created_at, additional_info
`

type InsertProcessEventParams struct {
	ProcessID      pgtype.Int4      `json:"process_id"`
	Event          ProcessEventType `json:"event"`
	AdditionalInfo []byte           `json:"additional_info"`
}

func (q *Queries) InsertProcessEvent(ctx context.Context, arg InsertProcessEventParams) (ProcessEvent, error) {
	row := q.db.QueryRow(ctx, insertProcessEvent, arg.ProcessID, arg.Event, arg.AdditionalInfo)
	var i ProcessEvent
	err := row.Scan(
		&i.ID,
		&i.ProcessID,
		&i.Event,
		&i.CreatedAt,
		&i.AdditionalInfo,
	)
	return i, err
}

const insertProcessStats = `-- name: InsertProcessStats :one
INSERT INTO process_stats (process_id, cpu_usage, cpu_usage_percentage, memory_usage)
VALUES ($1, $2, $3, $4) RETURNING id, process_id, created_at, cpu_usage, cpu_usage_percentage, memory_usage
`

type InsertProcessStatsParams struct {
	ProcessID          pgtype.Int4 `json:"process_id"`
	CpuUsage           int64       `json:"cpu_usage"`
	CpuUsagePercentage float64     `json:"cpu_usage_percentage"`
	MemoryUsage        int64       `json:"memory_usage"`
}

func (q *Queries) InsertProcessStats(ctx context.Context, arg InsertProcessStatsParams) (ProcessStat, error) {
	row := q.db.QueryRow(ctx, insertProcessStats,
		arg.ProcessID,
		arg.CpuUsage,
		arg.CpuUsagePercentage,
		arg.MemoryUsage,
	)
	var i ProcessStat
	err := row.Scan(
		&i.ID,
		&i.ProcessID,
		&i.CreatedAt,
		&i.CpuUsage,
		&i.CpuUsagePercentage,
		&i.MemoryUsage,
	)
	return i, err
}

const lastProcessLogFile = `-- name: LastProcessLogFile :one
SELECT id, process_id, start_time, end_time, path
FROM logs
WHERE process_id = $1
ORDER BY id DESC LIMIT 1
`

func (q *Queries) LastProcessLogFile(ctx context.Context, processID pgtype.Int4) (Log, error) {
	row := q.db.QueryRow(ctx, lastProcessLogFile, processID)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.ProcessID,
		&i.StartTime,
		&i.EndTime,
		&i.Path,
	)
	return i, err
}

const newProcessLogFile = `-- name: NewProcessLogFile :one
INSERT INTO logs (process_id, path)
VALUES ($1, $2) RETURNING id, process_id, start_time, end_time, path
`

type NewProcessLogFileParams struct {
	ProcessID pgtype.Int4 `json:"process_id"`
	Path      string      `json:"path"`
}

func (q *Queries) NewProcessLogFile(ctx context.Context, arg NewProcessLogFileParams) (Log, error) {
	row := q.db.QueryRow(ctx, newProcessLogFile, arg.ProcessID, arg.Path)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.ProcessID,
		&i.StartTime,
		&i.EndTime,
		&i.Path,
	)
	return i, err
}

const setLogEndTime = `-- name: SetLogEndTime :exec
UPDATE logs
SET end_time=$2
WHERE id = $1
`

type SetLogEndTimeParams struct {
	ID      int32            `json:"id"`
	EndTime pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) SetLogEndTime(ctx context.Context, arg SetLogEndTimeParams) error {
	_, err := q.db.Exec(ctx, setLogEndTime, arg.ID, arg.EndTime)
	return err
}

const setProcessConfiguration = `-- name: SetProcessConfiguration :exec
UPDATE process
SET configuration=$2
WHERE id = $1
`

type SetProcessConfigurationParams struct {
	ID            int32         `json:"id"`
	Configuration Configuration `json:"configuration"`
}

func (q *Queries) SetProcessConfiguration(ctx context.Context, arg SetProcessConfigurationParams) error {
	_, err := q.db.Exec(ctx, setProcessConfiguration, arg.ID, arg.Configuration)
	return err
}

const setProcessEnabled = `-- name: SetProcessEnabled :exec
UPDATE process
SET enabled=$2
WHERE id = $1
`

type SetProcessEnabledParams struct {
	ID      int32 `json:"id"`
	Enabled bool  `json:"enabled"`
}

func (q *Queries) SetProcessEnabled(ctx context.Context, arg SetProcessEnabledParams) error {
	_, err := q.db.Exec(ctx, setProcessEnabled, arg.ID, arg.Enabled)
	return err
}

const setProcessStatus = `-- name: SetProcessStatus :exec
UPDATE process
SET status=$2
WHERE id = $1
`

type SetProcessStatusParams struct {
	ID     int32         `json:"id"`
	Status ProcessStatus `json:"status"`
}

func (q *Queries) SetProcessStatus(ctx context.Context, arg SetProcessStatusParams) error {
	_, err := q.db.Exec(ctx, setProcessStatus, arg.ID, arg.Status)
	return err
}

const updateProcess = `-- name: UpdateProcess :one
UPDATE process
SET name=$2,
    process_group_id=$3,
    color=$4,
    executable_path=$5,
    arguments=$6,
    working_directory=$7,
    environment=$8,
    configuration=$9,
    enabled=$10
WHERE id = $1 RETURNING id, name, process_group_id, color, enabled, executable_path, arguments, working_directory, environment, status, configuration
`

type UpdateProcessParams struct {
	ID               int32             `json:"id"`
	Name             string            `json:"name"`
	ProcessGroupID   pgtype.Int4       `json:"process_group_id"`
	Color            pgtype.Text       `json:"color"`
	ExecutablePath   string            `json:"executable_path"`
	Arguments        string            `json:"arguments"`
	WorkingDirectory string            `json:"working_directory"`
	Environment      map[string]string `json:"environment"`
	Configuration    Configuration     `json:"configuration"`
	Enabled          bool              `json:"enabled"`
}

func (q *Queries) UpdateProcess(ctx context.Context, arg UpdateProcessParams) (Process, error) {
	row := q.db.QueryRow(ctx, updateProcess,
		arg.ID,
		arg.Name,
		arg.ProcessGroupID,
		arg.Color,
		arg.ExecutablePath,
		arg.Arguments,
		arg.WorkingDirectory,
		arg.Environment,
		arg.Configuration,
		arg.Enabled,
	)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProcessGroupID,
		&i.Color,
		&i.Enabled,
		&i.ExecutablePath,
		&i.Arguments,
		&i.WorkingDirectory,
		&i.Environment,
		&i.Status,
		&i.Configuration,
	)
	return i, err
}

const updateProcessGroup = `-- name: UpdateProcessGroup :one
UPDATE process_group
SET name=$2,
    color=$3,
    scripts_configuration=$4
WHERE id = $1 RETURNING id, name, color, scripts_configuration
`

type UpdateProcessGroupParams struct {
	ID                   int32         `json:"id"`
	Name                 string        `json:"name"`
	Color                pgtype.Text   `json:"color"`
	ScriptsConfiguration Configuration `json:"scripts_configuration"`
}

func (q *Queries) UpdateProcessGroup(ctx context.Context, arg UpdateProcessGroupParams) (ProcessGroup, error) {
	row := q.db.QueryRow(ctx, updateProcessGroup,
		arg.ID,
		arg.Name,
		arg.Color,
		arg.ScriptsConfiguration,
	)
	var i ProcessGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.ScriptsConfiguration,
	)
	return i, err
}
